import numpy as np
from scipy.optimize import least_squares
from pybaselines import Baseline


class SEC:
    def __init__(self, data_filename):
        """
        The SEC class holds a set of traces generated by a size
        exclusion chromatograph and provides a number of methods to
        manipulate them for data analysis

        Parameters
        ----------
        data_filename : string
            A string with the filename of a .txt or .csv file that
            contains the experimental data
        
        Attributes
        ----------
        gpc_traces : 2darray
            A 2D numpy array containing the intensities of the GPC
            chromatograms stored within the experiment file.
        edited_traces : 2darray
            A copy of the gpc_traces array in which data manipulation
            occurs without modifying the original data
        retention_times : 1darray
            A 1D numpy array containing the retention times at which
            the intensities are measured
        colors : list
            A list of the colors associated with each trace
        names : list
            A list of the name of each trace
        mol_weights : 1darray
            A 1D numpy array containing the molecular weights,
            calculated from calibration curve parameters
        """
        # The skip_header=2 is inherent to the data files
        # generated from the Tosoh EcoSEC software
        raw_traces = np.genfromtxt(data_filename, skip_header=2)
        
        # The intensities are in every other column of the raw
        # experimental text file, another feature specific to the
        # Tosoh SEC data
        self.gpc_traces = np.atleast_2d(raw_traces[:,1::2])
        self.edited_traces = self.gpc_traces.copy()
        
        # The Tosoh EcoSEC HPLC8320-GPC measures the response of
        # its detectors at a fixed frequency which remains
        # unchanged, allowing us to represent the retention times
        # using only the first column of the data file
        self.retention_times = raw_traces[:,0]
        self.mol_weights = None

        # Pre-calculate length to avoid repeated shape calculations
        self._num_traces = self.gpc_traces.shape[1]

        # Aesthetic items
        self.colors = ['#000000'] * self._num_traces
        self.names = [f'Trace {i+1}' for i in range(self._num_traces)]
        

    def get_time_position(self, time=None):
        """
        A method that returns the index of a time within the retention
        times attribute

        Parameters
        ----------
        time : float
            The retention time for which to find the position

        Returns
        -------
        index : int
            The index of the specified retention time
        """
        if time is None:
            return None
        
        return np.searchsorted(self.retention_times, time)
    

    def get_weight_position(self, weight=None):
        """
        A method that returns the index of a molecular weight within
        the molecular weights attribute

        Parameters
        ----------
        weight : float
            The molecular weight for which to find the position

        Returns
        -------
        index : int
            The index of the specified molecular weight
        """
        # If the retention times are monotonically increasing as they
        # should, then the molecular weights should be monotonically
        # decreasing so they are negated to convert them into a
        # monotonically increasing series
        if weight is None or self.mol_weights is None:
            return None
        
        index = np.searchsorted(self.mol_weights[::-1], weight)
        return len(self.mol_weights) - index
    

    def add_calibration(self, params, method='linear'):
        """
        A method that calculates the number average, weight average
        and dispersity of a peak within the specified bounds.

        Parameters
        ----------
        params : dict
            A dictionary containing the fitting parameters for the
            calibration curve
        method : string
            The calibration method, currently a few are supported
                linear : A linear calibration curve with dictionary
                         keys 'a' and 'b' where log10(mw)=at+b
                cubic : A cubic calibration curve with dictionary
                        keys 'a', 'b', 'c', and 'd' where
                        log10(mw)=at^3+bt^2+ct+d
        """
        if method=='linear':
            self.mol_weights = (params['a'] * self.retention_times +
                                params['b'])
            
        elif method=='cubic':
            self.mol_weights = (params['a']*self.retention_times**3 +
                                params['b']*self.retention_times**2 +
                                params['c']*self.retention_times +
                                params['d'])
        else:
            raise ValueError(f'Unknown calibration method: {method}')

        self.mol_weights = 10**(self.mol_weights)
        

    def _define_line(self, lbound, rbound, trace):
        """
        Creates a line between two points, this is a helper method
        for linear baseline correction and peak cutting

        Parameters
        ----------
        lbound : int
            The left bound for the line
        rbound : int
            The right bound for the line
        trace : int
            The index of the trace for which to return a line

        Returns
        -------
        line : 1darray
            The y values of a line spanning the left bound and the
            right bound on the specified trace
        """
        slope = ((self.edited_traces[rbound, trace]-
                  self.edited_traces[lbound, trace])
                 /(self.retention_times[rbound]-
                   self.retention_times[lbound]))

        line = (slope*(self.retention_times[lbound:rbound]
                       -self.retention_times[lbound])
                +self.edited_traces[lbound, trace])
        
        return line
    

    def area_calculator(self, lbound, rbound, cut, trace):
        """
        A method that calculates the area of a peak in a gpc
        chromatogram

        Parameters
        ----------
        lbound : int
            The left bound for the region where the peak normalization
            is done
        rbound : int
            The right bound for the region where the peak
            normalization is done
        cut : bool
            Whether to but the peak at the two endpoints

        Returns
        -------
        area : float
            The surface area of the peak
        """
        lindex = self.get_weight_position(rbound)
        rindex = self.get_weight_position(lbound)
        
        peak = self.edited_traces[lindex:rindex, trace].copy()

        if cut:
            peak -= self._define_line(lindex, rindex, trace)

        return np.trapezoid(peak, self.retention_times[lindex:rindex])
        

    def peak_calculator(self, lbound, rbound, cut, trace):
        """
        A method that calculates the number average, weight average
        and dispersity of a peak within the specified bounds.

        Parameters
        ----------
        lbound : int
            The left bound for the region where the peak normalization
            is done
        rbound : int
            The right bound for the region where the peak
            normalization is done
        cut : bool
            Whether to but the peak at the two endpoints

        Returns
        -------
        n_avg : float
            The number average molecular weight
        w_avg : float
            The weight average molecular weight
        dist : float
            The dispersity
        """
        lindex = self.get_weight_position(rbound)
        rindex = self.get_weight_position(lbound)
        mw_range = self.mol_weights[lindex:rindex]
        
        peak = self.edited_traces[lindex:rindex, trace].copy()
        
        if cut:
            peak -= self._define_line(lindex, rindex, trace)
            
        w_avg = (np.trapezoid(peak*mw_range, mw_range)/
                 np.trapezoid(peak, mw_range))
        n_avg = (np.trapezoid(peak, mw_range)/
                 np.trapezoid(peak/mw_range, mw_range))
        disp = w_avg/n_avg
        
        return [n_avg, w_avg, disp]
    

    def adjust_baseline(self, option):
        """
        A method that changes the baseline of the distribution

        Parameters
        ----------
        option : string
            The name of the technique to use for the baseline
            correction
                loess : Implements locally estimated scatterplot
                        smoothing algorithm for baseline correction,
                        uses symmetric weights to properly account for
                        negative peaks
                stdev : Implements the standard deviation distribution
                        algorithm for baseline correction
        """
        # Creating the baseline fitting object that will be used
        # for all of the baseline fitting options
        baseline_fitter = Baseline(
            self.retention_times, check_finite=False
        )

        if option=='none':
            return None

        methods = {
            'loess' : lambda data : baseline_fitter.loess(
                data, symmetric_weights=True, fraction=0.35,
                scale=1.5, poly_order=2),
            'stdev' : lambda data : baseline_fitter.std_distribution(
                data)
        }

        if option not in methods:
            raise ValueError(f"Unknown baseline option: {option}")

        for i in range(self._num_traces):
            baseline, params = methods[option](self.edited_traces[:, i])
            self.edited_traces[:, i] -= baseline
            
            
    def peak_normalize(self, style, lbound=None, rbound=None,
                       ind_var='rt'):
        """
        A method that normalizes the peak of the GPC traces to one
        for each of the chromatograms in self.gpc_traces

        Parameters
        ----------
        style : str or float or int
            How to format the peak normalization. The following values
            are recognized
                individual : each peak is normalized individually
                global : the peaks are normalized against the largest
                         global value
            If the value is a float or int, then all traces are given
            the same value at that molecular weight or retention time
            and then globally nromalized
        lbound : float
            The left bound for the region where the peak normalization
            is done
        rbound : float
            The right bound for the region where the peak
            normalization is done
        ind_var : str
            Whether the desired axis is retention time or molecular
            weight
                rt : retention time
                mw : molecular weight
        """
        lbound = lbound if lbound is not None else 0
        rbound = rbound if rbound is not None else -1
        
        if style == 'individual':
            maxima = np.max(self.edited_traces[lbound:rbound], axis=0)
            self.edited_traces /= maxima
                
        elif style == 'global':
            self.edited_traces /= np.max(self.edited_traces[lbound:rbound])

        else:
            if ind_var == 'rt':
                point = self.get_time_position(style)
            elif ind_var == 'mw':
                point = self.get_time_position(style)
            for trace in range(self.__len__()):
                height = self.edited_traces[point, trace]
                self.edited_traces[:, trace] /= height
            self.edited_traces /= np.max(self.edited_traces[lbound:rbound])
            

    def deconvolute(self, peaks, trace, lbound, rbound):
        """
        A method that deconvolutes a trace into multiple gaussian
        peaks

        Parameters
        ----------
        peaks : int
            The number of peaks to deconvolute the trace into
        trace : int
            The identity of the trace for which to perform the
            deconvolution
        lbound : float
            The left bound for the region where the peak normalization
            is done (must represent a molecular weight)
        rbound : foat
            The right bound for the region where the peak
            normalization is done (must represent a molecular weight)

        Returns
        -------
        mns : list
            A list containing the number average molecular weights
            of the peaks
        mws : list
            A list containing the weight average molecular weights
            of the peaks
        disp : list
            A list containing the dispersities of the peaks
        areas : list
            A list containing the areas of each of the peaks
            (normalized to 100)
        new_peaks : 2darray
            An array containing the fitted peaks
        """

        def gaussian(mws, mn, d):
            sigma = np.sqrt(np.log(d))
            power = -((np.log(mws)-np.log(mn/d))**2)/(2*sigma**2)
            return np.exp(power)/sigma/np.sqrt(2*np.pi)

        def resids(params, mws, meas_trace, peaks, penalty):
            new_trace = np.zeros_like(meas_trace)
            for i in range(peaks):
                new_trace += params[3*i+2]*gaussian(mws, params[3*i],
                                                    params[3*i+1])
            calc_resids = new_trace - meas_trace
            calc_resids[calc_resids>0] *= penalty
            return calc_resids
        
        irbound = self.get_weight_position(lbound)
        ilbound = self.get_weight_position(rbound)

        init_guess = []
        bounds = ([], [])
        for i in range(peaks):
            # Initial guess for mn for all peaks is the average of the
            # bounds
            init_guess.append(np.exp((np.log(lbound)+np.log(rbound))/2))
            bounds[0].append(lbound)
            bounds[1].append(rbound)
            # Initial guess for the dispersity
            init_guess.append(1.1)
            bounds[0].append(1.0)
            bounds[1].append(3.0)
            # Initial guess for the weight
            init_guess.append(1.0)
            bounds[0].append(0)
            bounds[1].append(np.inf)

        penalty = 10
        res = least_squares(resids, init_guess, bounds=bounds,
                            args=(self.mol_weights[ilbound:irbound],
                                  self.edited_traces[ilbound:irbound, trace],
                                  peaks, penalty))

        mns = res['x'][::3]
        disp = res['x'][1::3]
        mws = mns*disp
        areas = 100 * res['x'][2::3] / np.sum(res['x'][2::3])
        
        new_peaks = np.zeros((len(self.mol_weights), peaks))
        for i in range(peaks):
            new_peaks[:, i] = res['x'][3*i+2]*gaussian(self.mol_weights,
                                                       mns[i], disp[i])

        return {
            'mns' : mns,
            'mws': mws,
            'disp': disp,
            'areas': areas,
            'x' : self.mol_weights,
            'peaks' : new_peaks
        }


    def reset_traces(self):
        """
        A method that resets the edited traces attribute in order to
        refresh it for new manipulation
        """
        self.edited_traces = self.gpc_traces.copy()

        
    def append(self, new_sec):
        """
        A method that adds the traces from another sec object to the
        current sec object

        Parameters
        ----------
        new_trace: SEC
            Another sec trace from which the traces are desired to be
            added
        """
        # Add some sort of code to check to make sure that the
        # retention times are identical; for now this is not needed
        new_traces = np.concatenate((self.gpc_traces,
                                     new_sec.gpc_traces),
                                    axis=1)
        self.gpc_traces = new_traces
        self.colors = self.colors + new_sec.colors
        self.names = self.names + new_sec.names
        self._num_traces += new_sec._num_traces

    def __len__(self):
        """
        A method that returns how many traces are in the GPC object

        Returns
        -------
        length : float
            The number of traces within the GPC object
        """
        return self._num_traces

